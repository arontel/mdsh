## Modules

~~~shell
    $ source "$BASHER_INSTALL_BIN/mdsh"; set +e
~~~

### @provide

The `@provide` function defines a function that will be run if the named module is `@require`d later.  You can `@provide` the same module more than once, but only until it has been `@require`d.  `@require` without a command then runs the saved command, or gives an error.

~~~shell
    $ ( @provide )
    No command given for @provide at line 4 NULL
    [64]

    $ ( @provide thingy )
    No command given for @provide at line 6 NULL
    [64]

    $ ( @require thingy )
    No @provide defined for module thingy at line 8 NULL
    [70]

    $ @provide thingy echo "yada yada"
    $ declare -f @provide-thingy
    @provide-thingy () 
    { 
        echo yada\ yada
    }

    $ @provide thingy echo blah
    $ declare -f @provide-thingy
    @provide-thingy () 
    { 
        echo blah
    }

    $ @require thingy
    blah

    $ @require thingy   # already loaded, so no-op

    $ ( @provide thingy echo boom )
    Module thingy already loaded; attempted redefinition at line 22 NULL
    [70]
~~~

### @require

The `@require` function should run its arguments on first use, but not subsequent uses with the same module name:

~~~shell
    $ @require foo echo "first!"
    first!
    $ @require foo echo "first!"
    $ @require bar echo "second"
    second
~~~

While executing, `@is-main` should return false, and the command should see a local value of `MDSH_MODULE` equal to the module name:

~~~shell
    $ load() { @is-main || echo "not main"; echo "$MDSH_MODULE"; }
    $ @require baz load
    not main
    baz
~~~

This value should *not* be exported to other processes, and `@is-main` should normally return truth:

~~~shell
    $ @require spam bash -c 'echo ${MDSH_MODULE-safe!}'
    safe!
    $ @is-main && echo "is main"
    is main
~~~

Also, even though `@require` uses `<>` internally to delimit the list of loaded modules, it should not be possible to corrupt this list by using those characters inside a module name:

````sh
    $ @require '<thing1><thing2>' echo trying corruption
    trying corruption
    $ @require 'thing1' echo "didn't work!"
    didn't work!
````

### "Main" Blocks

The compilation system uses `MDSH_MODULE` to decide whether to execute `shell main` and `mdsh main` blocks, e.g. when these blocks are compiled:

```shell main
#!/usr/bin/env bash
# This file header is only included when built as a main program
```

```shell
# This line is always here
```

```shell mdsh
echo "# And so is this"
```

```shell mdsh main
echo "# This footer is only in the main program"
```

The result is different depending on whether it's done as a module or not:

~~~shell
    $ @require zebra mdsh-source "$TESTDIR/$TESTFILE"
    # This line is always here
    # And so is this

    $ mdsh-source "$TESTDIR/$TESTFILE"
    #!/usr/bin/env bash
    # This file header is only included when built as a main program
    # This line is always here
    # And so is this
    # This footer is only in the main program
~~~

### Headers and Footers

#### @module

`@module` *name* creates a shebang header and edit warning, if invoked by the top-level module:

~~~shell
    $ @module foo.md
    #!/usr/bin/env bash
    # ---
    # This file is automatically generated from foo.md - DO NOT EDIT
    # ---
    
    $ MDSH_MODULE=x @module blah.md
~~~

#### @comment

`@comment` *filename* incorporates the contents of the named file as shell comments, e.g.:

~~~shell
    $ echo -e "hey\n\nthere" >testfile
    $ MDSH_SOURCE=x @comment testfile
    # hey
    #
    # there
    
~~~

#### @main

`@main` *funcname* adds code to the **end** of the currently-compiling file that will execute *funcname*, if and only if the executing file is the top-level bash script (i.e., not being sourced):

~~~shell
    $ MDSH_MODULE=x @main fizz   # no-op during @require

    $ mdsh-source >f <<'EOF'
    > ```mdsh
    > echo "# code"
    > @main bar
    > @require whee mdsh-source "$TESTDIR/$TESTFILE"
    > @main foo   # only the last call to @main counts
    > echo "# more code"
    > ```
    > ```shell
    > foo() { echo "echo self-modify or external change" >>f; }
    > ```
    > EOF

    $ cat f
    # code
    # This line is always here
    # And so is this
    # more code
    foo() { echo "echo self-modify or external change" >>f; }
    if [[ $0 == "${BASH_SOURCE-}" ]]; then foo "$@"; exit; fi

# if @main didn't exit, the output would be 'self-modify or external change'
    $ bash ./f
~~~

